/**
 * ===== REALUNIVERSE AI MASTER LIBRARY =====
 * Version: 1.1.0 (Thinking Mode with 2 API Calls)
 */

/* ------------------ CONFIGURATION ------------------ */

const API_URL = 'https://api.openai.com/v1/chat/completions';
const RESPONSES_API_URL = 'https://api.openai.com/v1/responses';
const IMAGE_API_URL = 'https://api.openai.com/v1/images/generations';

// Model Configuration for different modes
const MODEL_CONFIG = {
  action_standard: { model: 'gpt-4.1', max_tokens: 12000 },
  action_turbo: { model: 'gpt-4.1', max_tokens: 25000 },
  array: { model: 'gpt-4.1', max_tokens: 2000 },
  image: { model: 'dall-e-3', size: '1024x1024', quality: 'hd', n: 1 }
};

// ‚≠ê NEW: Thinking Mode Config
const THINKING_MODE_CONFIG = {
  thinking_api: { model: 'gpt-4.1', max_tokens: 3000 },
  answer_api: { model: 'gpt-4.1', max_tokens: 15000 }
};

const TEMPERATURE_PRESETS = [0, 0.2, 0.4, 0.7];

// Turbo Mode Settings
const TURBO_CHUNK_CHAR_LIMIT_ACTION = 20000;
const MAX_TOTAL_ROWS_TURBO = 10000;
const PARALLEL_BATCH_SIZE = 3;
const PARALLEL_DELAY_MS = 1000;

// Array Mode Settings
const MAX_ROWS_PER_BATCH_ARRAY = 25;
const MAX_TOTAL_ROWS_ARRAY = 10000;

// UI Settings
const SIDEBAR_WIDTH = 600;
const SIDEBAR_HEIGHT = 900;
const CHAT_SHEET_NAME = 'ChatHistory';
const DEBUG_LOG_SHEET_NAME = 'DebugLog';

/* ------------------ DYNAMIC PRESET FUNCTIONS ------------------ */

function getDynamicPresets() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Preset');

  if (!sheet) {
    throw new Error('‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö Sheet "Preset" ‡πÇ‡∏õ‡∏£‡∏î‡∏™‡∏£‡πâ‡∏≤‡∏á Sheet ‡∏ä‡∏∑‡πà‡∏≠ "Preset" ‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô');
  }

  try {
    const presets = {
      action: {},
      array: {},
      image: {}
    };

    const actionRange = sheet.getRange('A2:B21');
    const actionValues = actionRange.getValues();

    actionValues.forEach((row, index) => {
      const [name, systemMessage] = row;
      if (name && String(name).trim() && systemMessage && String(systemMessage).trim()) {
        const key = `action_preset_${index + 2}`;
        presets.action[key] = {
          SYSTEM_MESSAGE: `Preset!B${index + 2}`,
          DISPLAY_NAME: String(name).trim(),
          ROW_NUMBER: index + 2
        };
      }
    });

    const arrayRange = sheet.getRange('D2:E21');
    const arrayValues = arrayRange.getValues();

    arrayValues.forEach((row, index) => {
      const [name, systemMessage] = row;
      if (name && String(name).trim() && systemMessage && String(systemMessage).trim()) {
        const key = `array_preset_${index + 2}`;
        presets.array[key] = {
          SYSTEM_MESSAGE: `Preset!E${index + 2}`,
          DISPLAY_NAME: String(name).trim(),
          ROW_NUMBER: index + 2
        };
      }
    });

    const imageRange = sheet.getRange('G2:H21');
    const imageValues = imageRange.getValues();

    imageValues.forEach((row, index) => {
      const [name, promptTemplate] = row;
      if (name && String(name).trim() && promptTemplate && String(promptTemplate).trim()) {
        const key = `image_preset_${index + 2}`;
        presets.image[key] = {
          SYSTEM_MESSAGE: `Preset!H${index + 2}`,
          DISPLAY_NAME: String(name).trim(),
          ROW_NUMBER: index + 2
        };
      }
    });

    if (Object.keys(presets.action).length === 0 && Object.keys(presets.array).length === 0) {
      throw new Error('‚ùå Sheet "Preset" ‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤\n\n‡πÇ‡∏õ‡∏£‡∏î‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Preset:\n- Action Presets: ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå A-B (‡∏ä‡∏∑‡πà‡∏≠-‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á)\n- Array Presets: ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå D-E (‡∏ä‡∏∑‡πà‡∏≠-‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á)');
    }

    Logger.log('Dynamic presets loaded successfully:');
    Logger.log('Action presets: ' + Object.keys(presets.action).length);
    Logger.log('Array presets: ' + Object.keys(presets.array).length);

    return presets;

  } catch (e) {
    if (e.message.includes('‚ùå')) throw e;
    throw new Error('‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô Sheet "Preset":\n' + e.message);
  }
}

function getPresetDescriptionByKey(presetKey) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Preset');
    if (!sheet) return '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢';

    if (presetKey.includes('action_preset_')) {
      const rowNum = presetKey.split('_')[2];
      const descValue = sheet.getRange(`C${rowNum}`).getValue();
      if (descValue && String(descValue).trim()) return String(descValue).trim();
    } else if (presetKey.includes('array_preset_')) {
      const rowNum = presetKey.split('_')[2];
      const descValue = sheet.getRange(`F${rowNum}`).getValue();
      if (descValue && String(descValue).trim()) return String(descValue).trim();
    } else if (presetKey.includes('image_preset_')) {
      const rowNum = presetKey.split('_')[2];
      const descValue = sheet.getRange(`I${rowNum}`).getValue();
      if (descValue && String(descValue).trim()) return String(descValue).trim();
    }

    return '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢';
  } catch (e) {
    return '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÑ‡∏î‡πâ';
  }
}

/* ------------------ MAIN LIBRARY FUNCTIONS ------------------ */

function onOpen() {
  initializeRealUniverse();
}

function initializeRealUniverse() {
  const ui = SpreadsheetApp.getUi();

  try {
    ui.createMenu('‚óâ‚Éù‚óâ RealUniverse')
      .addItem('‚ÜóÔ∏è Launch AI', 'launchRealUniverseAI')
      .addSeparator()
      .addItem('‚öôÔ∏è Set API Key', 'setupRealUniverseApiKey')
      .addItem('üóëÔ∏è Clear Chat History', 'clearRealUniverseHistory')
      .addToUi();

  } catch (e) {
    Logger.log('Error initializing RealUniverse: ' + e.message);
    ui.alert('Installation Error',
      'There was an error setting up RealUniverse AI. Please try refreshing the page and running the installation again.',
      ui.ButtonSet.OK);
  }
}

function launchRealUniverseAI() {
  showRealUniverseChat();
}

function showRealUniverseChat() {
  try {
    const properties = PropertiesService.getScriptProperties();
    const displayMode = 'modeless';

    if (displayMode === 'sidebar') {
      showRealUniverseSidebar();
    } else {
      showRealUniverseModeless();
    }

  } catch (e) {
    Logger.log('Error showing chat: ' + e.message);
    SpreadsheetApp.getUi().alert('Error', 'Could not launch AI interface: ' + e.message, SpreadsheetApp.getUi().ButtonSet.OK);
  }
}

function showRealUniverseSidebar() {
  try {
    const properties = PropertiesService.getScriptProperties();
    properties.setProperty('REALUNIVERSE_DISPLAY_MODE', 'sidebar');

    const htmlContent = getRealUniverseHtmlContent();
    const html = HtmlService.createHtmlOutput(htmlContent).setWidth(320);

    SpreadsheetApp.getUi().showSidebar(html.setTitle(' '));
  } catch (e) {
    Logger.log('Error showing sidebar: ' + e.message);
    SpreadsheetApp.getUi().alert('Error', 'Could not launch sidebar: ' + e.message, SpreadsheetApp.getUi().ButtonSet.OK);
  }
}

function showRealUniverseModeless() {
  try {
    const properties = PropertiesService.getScriptProperties();
    properties.setProperty('REALUNIVERSE_DISPLAY_MODE', 'modeless');

    const htmlContent = getRealUniverseHtmlContent();
    const html = HtmlService.createHtmlOutput(htmlContent);
    html.setWidth(SIDEBAR_WIDTH).setHeight(SIDEBAR_HEIGHT);

    SpreadsheetApp.getUi().showModelessDialog(html, ' ');
  } catch (e) {
    Logger.log('Error showing modeless: ' + e.message);
    SpreadsheetApp.getUi().alert('Error', 'Could not launch modeless dialog: ' + e.message, SpreadsheetApp.getUi().ButtonSet.OK);
  }
}

function toggleDisplayMode() {
  try {
    const properties = PropertiesService.getScriptProperties();
    const currentMode = properties.getProperty('REALUNIVERSE_DISPLAY_MODE') || 'modeless';

    const newMode = currentMode === 'modeless' ? 'sidebar' : 'modeless';
    properties.setProperty('REALUNIVERSE_DISPLAY_MODE', newMode);

    const ui = SpreadsheetApp.getUi();
    const emptyHtml = HtmlService.createHtmlOutput('<script>google.script.host.close();</script>');

    if (currentMode === 'modeless') {
      emptyHtml.setWidth(1).setHeight(1);
      ui.showModelessDialog(emptyHtml, 'Closing...');
      Utilities.sleep(150);
    } else {
      emptyHtml.setWidth(1);
      ui.showSidebar(emptyHtml.setTitle('Closing...'));
      Utilities.sleep(150);
    }

    const htmlContent = getRealUniverseHtmlContent();
    const html = HtmlService.createHtmlOutput(htmlContent);

    if (newMode === 'sidebar') {
      html.setWidth(320);
      ui.showSidebar(html.setTitle(' '));
    } else {
      html.setWidth(SIDEBAR_WIDTH).setHeight(SIDEBAR_HEIGHT);
      ui.showModelessDialog(html, ' ');
    }

  } catch (e) {
    Logger.log('Error toggling display mode: ' + e.message);
    SpreadsheetApp.getUi().alert('Error', 'Could not switch display mode: ' + e.message, SpreadsheetApp.getUi().ButtonSet.OK);
  }
}

function getCurrentDisplayMode() {
  try {
    const properties = PropertiesService.getScriptProperties();
    return properties.getProperty('REALUNIVERSE_DISPLAY_MODE') || 'modeless';
  } catch (e) {
    Logger.log('Error getting display mode: ' + e.message);
    return 'modeless';
  }
}

function setupRealUniverseApiKey() {
  const ui = SpreadsheetApp.getUi();
  const response = ui.prompt(
    'Set OpenAI API Key',
    'Please enter your OpenAI API key (starts with "sk-"):\n\nYou can get one from: https://platform.openai.com/api-keys',
    ui.ButtonSet.OK_CANCEL
  );

  if (response.getSelectedButton() == ui.Button.OK) {
    const apiKey = response.getResponseText().trim();
    if (apiKey.startsWith('sk-')) {
      PropertiesService.getScriptProperties().setProperty('REALUNIVERSE_API_KEY', apiKey);
      ui.alert('Success!', 'Your API Key has been saved securely. You can now use RealUniverse AI!', ui.ButtonSet.OK);
    } else {
      ui.alert('Error', 'Invalid API Key format. It must start with "sk-".', ui.ButtonSet.OK);
    }
  }
}

/* ------------------ CORE AI PROCESSING FUNCTIONS ------------------ */

/**
 * ‚≠ê UPDATED: Added thinkingMode parameter
 */
function processRealUniverseAI(prompt, preset, temperature, mode, turboMode, thinkingMode) {
  try {
    preset = preset || 'action_preset_2';
    temperature = temperature || 0;
    mode = mode || 'action';
    turboMode = turboMode || false;
    thinkingMode = thinkingMode || false;

    if (mode === 'action') {
      if (thinkingMode) {
        // ‚≠ê NEW: Use Thinking Mode (2 API calls)
        return processRealUniverseWithThinking(prompt, preset, temperature, turboMode);
      } else if (turboMode) {
        return processRealUniverseTurbo(prompt, preset, temperature);
      } else {
        return processRealUniverseStandard(prompt, preset, temperature);
      }
    } else if (mode === 'array') {
      return processRealUniverseArray(prompt, preset, temperature);
    } else if (mode === 'image') {
      return processRealUniverseImage(prompt, preset, temperature);
    }

    throw new Error('Invalid mode specified');
  } catch (e) {
    Logger.log('Error in processRealUniverseAI: ' + e.message);
    return 'ERROR: ' + e.message;
  }
}

function isNumeric(value) {
  if (value == null || value === '') return false;
  const cleanedValue = String(value).replace(/,/g, '');
  return !isNaN(cleanedValue) && !isNaN(parseFloat(cleanedValue));
}

function processRealUniverseStandard(prompt, preset, temperature) {
  const systemMessage = getRealUniverseSystemMessage(getDynamicPresetSystemMessage(preset, 'action'), 'action');
  const config = MODEL_CONFIG.action_standard;

  let allDataArray = [];
  const rangeList = SpreadsheetApp.getActiveRangeList();
  if (rangeList) {
    const ranges = rangeList.getRanges();

    ranges.forEach(range => {
      let visibleRowsAndNumbers = getVisibleCellsForActionWithRowNumbers(range);
      visibleRowsAndNumbers.forEach(item => {
        const cleanedRow = item.data.map(val => cleanCellData(val));
        if (cleanedRow.some(val => val !== '')) {
          allDataArray.push({
            rowNumber: item.rowNumber,
            data: cleanedRow
          });
        }
      });
    });
  }

  const wordCount = allDataArray
    .map(row => row.data.join(' '))
    .join(' ')
    .split(/\s+/)
    .filter(word => word.length > 0)
    .length;

  if (wordCount > 20000) {
    const errorMessage = '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏°‡∏µ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‡πÇ‡∏õ‡∏£‡∏î‡πÉ‡∏ä‡πâ üí° Deep Analysis';
    saveRealUniverseHistory(prompt, errorMessage);
    return errorMessage;
  }

  const ranges = rangeList.getRanges();
  const firstRange = ranges[0];
  const sheetName = firstRange.getSheet().getName();
  const rangeNotation = ranges.map(r => r.getA1Notation()).join(', ');
  const totalCols = firstRange.getNumColumns();
  const totalRowsVisible = allDataArray.length;
  const rangeInfo = `Selected Range: ${sheetName}!${rangeNotation} (${totalCols} columns, ${totalRowsVisible} visible rows)`;

  const dataAnalysis = analyzeDataStructure(allDataArray);

  let enhancedPrompt = prompt;
  let enhancedSystemMessage = systemMessage;

  if (dataAnalysis.dataType === 'content_only') {
    enhancedSystemMessage += '\n\n‡∏Ñ‡∏∏‡∏ì‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤/‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°:\n' +
      '- ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏ï‡∏≤‡∏° Preset ‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î\n' +
      '- ‡∏´‡πâ‡∏≤‡∏°‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á‡πÄ‡∏•‡∏Ç Row ‡∏ó‡∏µ‡πà‡∏ô‡∏≥‡∏°‡∏≤‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÉ‡∏ô‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡πÄ‡∏î‡πá‡∏î‡∏Ç‡∏≤‡∏î\n';

    enhancedPrompt = formatContentOnlyData(allDataArray, prompt, rangeInfo);

  } else if (dataAnalysis.dataType === 'mixed_data') {
    const calculations = performCalculations(allDataArray, dataAnalysis);

    enhancedSystemMessage += '\n\n‡∏Ñ‡∏∏‡∏ì‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ö‡∏ö‡∏ú‡∏™‡∏° (‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° + ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç):\n' +
      '- ‡πÉ‡∏ä‡πâ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ó‡∏µ‡πà‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏à‡∏≤‡∏Å pre-processing\n' +
      '- ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏ï‡∏≤‡∏° Preset ‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î\n' +
      '- ‡∏´‡πâ‡∏≤‡∏°‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á‡πÄ‡∏•‡∏Ç Row ‡∏ó‡∏µ‡πà‡∏ô‡∏≥‡∏°‡∏≤‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÉ‡∏ô‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡πÄ‡∏î‡πá‡∏î‡∏Ç‡∏≤‡∏î\n';

    enhancedPrompt = formatMixedData(allDataArray, calculations, prompt, rangeInfo);
  }

  const payload = {
    model: config.model,
    messages: [
      { role: 'system', content: enhancedSystemMessage },
      { role: 'user', content: enhancedPrompt }
    ],
    temperature: temperature,
    max_tokens: config.max_tokens
  };

  const result = makeRealUniverseApiCallWithRetry(payload);
  saveRealUniverseHistory(prompt + ' (Smart)', result);
  return result;
}

/**
 * ‚≠ê NEW: Process with Thinking Mode (2 API Calls)
 */
function processRealUniverseWithThinking(prompt, preset, temperature, isTurbo) {
  const systemMessage = getRealUniverseSystemMessage(getDynamicPresetSystemMessage(preset, 'action'), 'action');
  const thinkingConfig = THINKING_MODE_CONFIG.thinking_api;
  const answerConfig = THINKING_MODE_CONFIG.answer_api;

  // Prepare data
  let allDataArray = [];
  const rangeList = SpreadsheetApp.getActiveRangeList();
  if (rangeList) {
    const ranges = rangeList.getRanges();

    ranges.forEach(range => {
      let visibleRowsAndNumbers = getVisibleCellsForActionWithRowNumbers(range);
      visibleRowsAndNumbers.forEach(item => {
        const cleanedRow = item.data.map(val => cleanCellData(val));
        if (cleanedRow.some(val => val !== '')) {
          allDataArray.push({
            rowNumber: item.rowNumber,
            data: cleanedRow
          });
        }
      });
    });
  }

  const ranges = rangeList.getRanges();
  const firstRange = ranges[0];
  const sheetName = firstRange.getSheet().getName();
  const rangeNotation = ranges.map(r => r.getA1Notation()).join(', ');
  const totalCols = firstRange.getNumColumns();
  const totalRowsVisible = allDataArray.length;
  const rangeInfo = `Selected Range: ${sheetName}!${rangeNotation} (${totalCols} columns, ${totalRowsVisible} visible rows)`;

  const dataAnalysis = analyzeDataStructure(allDataArray);

  let enhancedPrompt = prompt;
  let dataContext = '';

  if (dataAnalysis.dataType === 'content_only') {
    dataContext = formatContentOnlyData(allDataArray, '', rangeInfo);
  } else if (dataAnalysis.dataType === 'mixed_data') {
    const calculations = performCalculations(allDataArray, dataAnalysis);
    dataContext = formatMixedData(allDataArray, calculations, '', rangeInfo);
  }

  // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ API CALL #1: THINKING ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
  const thinkingSystemMessage = `${systemMessage}

‚≠ê YOUR TASK - THINKING & PLANNING PHASE:

You are in the THINKING stage. Your job is to:
1. Look at the data and observe what you see
2. Understand what the preset is asking for
3. Plan HOW you will analyze to meet the preset requirements

Think out loud naturally - like having an internal conversation with yourself.

Return JSON format:
{
  "thinking": [
    "‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•... ‡πÄ‡∏´‡πá‡∏ô [what you actually see in the data]",
    "‡∏≠‡∏∑‡∏° preset ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ [specific goal from preset]... ‡∏â‡∏±‡∏ô‡∏ï‡πâ‡∏≠‡∏á [specific approach]",
    "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏°‡∏µ [specific observation about data structure/content]... ‡∏â‡∏±‡∏ô‡∏à‡∏∞ [specific planned action]",
    "‡πÄ‡∏≠‡∏≤‡∏•‡πà‡∏∞ ‡∏°‡∏≤‡∏ß‡∏≤‡∏á‡πÅ‡∏ú‡∏ô: ‡∏Ç‡∏±‡πâ‡∏ô‡πÅ‡∏£‡∏Å [specific step], ‡πÅ‡∏•‡πâ‡∏ß [specific step], ‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ [specific step]",
    "‡πÇ‡∏≠‡πÄ‡∏Ñ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÅ‡∏•‡πâ‡∏ß ‡∏£‡∏π‡πâ‡∏ß‡πà‡∏≤‡∏à‡∏∞ [what exactly you will do next]"
  ]
}

CRITICAL RULES - MUST FOLLOW:
- Write as if you are CURRENTLY analyzing (use: ‡πÄ‡∏´‡πá‡∏ô, ‡∏•‡∏≠‡∏á, ‡∏î‡∏π, ‡∏â‡∏±‡∏ô‡∏à‡∏∞)
- NEVER use past tense (‡∏û‡∏ö‡∏ß‡πà‡∏≤, ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏•‡πâ‡∏ß, ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡πâ‡∏ß)
- Use natural Thai conversation: ‡∏≠‡∏∑‡∏°, ‡πÇ‡∏≠‡πâ, ‡πÄ‡∏≠‡∏≤‡∏•‡πà‡∏∞, ‡πÇ‡∏≠‡πÄ‡∏Ñ, ‡∏ô‡πà‡∏≤‡∏™‡∏ô‡πÉ‡∏à
- MUST be SPECIFIC to the actual data you see - mention actual numbers, columns, patterns
- NEVER use generic templates - each thinking MUST be unique to this specific data
- Show what you ACTUALLY SEE (example: "‡πÄ‡∏´‡πá‡∏ô 150 ‡πÅ‡∏ñ‡∏ß ‡∏°‡∏µ 3 ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå: ‡∏ä‡∏∑‡πà‡∏≠, ‡∏¢‡∏≠‡∏î‡∏Ç‡∏≤‡∏¢, ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà")
- Show what you PLAN TO DO (example: "‡∏â‡∏±‡∏ô‡∏à‡∏∞‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏¢‡∏≠‡∏î‡∏£‡∏ß‡∏° ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏≤‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ ‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÄ‡∏î‡∏∑‡∏≠‡∏ô")
- 5-8 thinking steps
- DO NOT provide final answer - only thinking/planning
- Return ONLY valid JSON`;

  const thinkingPayload = {
    model: thinkingConfig.model,
    messages: [
      { role: 'system', content: thinkingSystemMessage },
      { role: 'user', content: `${enhancedPrompt}\n\n${dataContext}` }
    ],
    temperature: temperature,
    max_tokens: thinkingConfig.max_tokens,
    response_format: { "type": "json_object" }
  };

  const thinkingRawResult = makeRealUniverseApiCallWithRetry(thinkingPayload);
  const thinkingResult = parseThinkingResponse(thinkingRawResult);

  if (!thinkingResult.thinking || thinkingResult.thinking.length === 0) {
    throw new Error('Failed to get thinking steps from API');
  }

  // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ API CALL #2: ANSWER ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
  const thinkingStepsText = thinkingResult.thinking.map((step, i) => `${i + 1}. ${step}`).join('\n');

  const answerSystemMessage = `${systemMessage}

‚≠ê YOUR TASK - EXECUTION PHASE:

You already analyzed and planned in the previous thinking phase.

YOUR THINKING & PLANNING:
${thinkingStepsText}

Now EXECUTE this plan and provide your FULL, DETAILED answer according to the preset.

CRITICAL REQUIREMENTS:
- Follow the plan you created above
- Provide comprehensive, detailed analysis (1200-2000 words)
- Meet all preset requirements
- This is your FINAL answer - make it complete and thorough
- DO NOT repeat the thinking steps in your answer
- Focus on delivering results, insights, and conclusions`;

  const answerPayload = {
    model: answerConfig.model,
    messages: [
      { role: 'system', content: answerSystemMessage },
      { role: 'user', content: `${enhancedPrompt}\n\n${dataContext}` }
    ],
    temperature: temperature,
    max_tokens: answerConfig.max_tokens
  };

  const finalAnswer = makeRealUniverseApiCallWithRetry(answerPayload);

  // Return combined result
  const combinedResult = {
    thinking: thinkingResult.thinking,
    answer: finalAnswer
  };

  saveRealUniverseHistory(prompt + ' (Thinking Mode)', finalAnswer);
  return JSON.stringify(combinedResult);
}

function getDynamicPresetSystemMessage(presetKey, mode) {
  try {
    const presets = getDynamicPresets();
    const modePresets = presets[mode] || {};

    if (modePresets[presetKey]) {
      return modePresets[presetKey].SYSTEM_MESSAGE;
    }

    const firstKey = Object.keys(modePresets)[0];
    if (firstKey) return modePresets[firstKey].SYSTEM_MESSAGE;

    throw new Error('No presets available for mode: ' + mode);
  } catch (e) {
    Logger.log('Error getting dynamic preset: ' + e.message);
    throw e;
  }
}

function analyzeDataStructure(dataArray) {
  if (!dataArray || dataArray.length === 0) {
    return { dataType: 'empty', columns: [] };
  }

  const sampleRow = dataArray[0].data;
  const columnAnalysis = [];

  for (let colIndex = 0; colIndex < sampleRow.length; colIndex++) {
    const columnValues = dataArray.map(row => row.data[colIndex]).filter(val => val !== '');
    if (columnValues.length === 0) continue;

    const numericValues = columnValues.filter(val => isNumeric(val));
    const uniqueValues = [...new Set(columnValues)];

    const numericRatio = numericValues.length / columnValues.length;
    const hasDuplicates = uniqueValues.length < columnValues.length;
    const duplicateRatio = hasDuplicates ? (columnValues.length - uniqueValues.length) / columnValues.length : 0;

    const analysis = {
      index: colIndex,
      type: 'unknown',
      hasNumbers: numericValues.length > 0,
      isNumeric: numericRatio > 0.8,
      isCategory: hasDuplicates && uniqueValues.length >= 2 && uniqueValues.length <= 20 && duplicateRatio > 0.2,
      isText: numericRatio < 0.3,
      uniqueCount: uniqueValues.length,
      totalCount: columnValues.length
    };

    if (analysis.isNumeric)      analysis.type = 'number';
    else if (analysis.isCategory) analysis.type = 'category';
    else if (analysis.isText)     analysis.type = 'text';
    else                          analysis.type = 'mixed';

    columnAnalysis.push(analysis);
  }

  const hasNumbers = columnAnalysis.some(col => col.type === 'number');
  const hasCategories = columnAnalysis.some(col => col.type === 'category');
  const hasText = columnAnalysis.some(col => col.type === 'text');

  let dataType = 'content_only';
  if (hasNumbers && (hasCategories || hasText)) dataType = 'mixed_data';

  return {
    dataType: dataType,
    columns: columnAnalysis,
    totalRows: dataArray.length,
    numberColumns: columnAnalysis.filter(col => col.type === 'number'),
    categoryColumns: columnAnalysis.filter(col => col.type === 'category'),
    textColumns: columnAnalysis.filter(col => col.type === 'text'),
    mixedColumns: columnAnalysis.filter(col => col.type === 'mixed')
  };
}

function formatContentOnlyData(dataArray, userPrompt, rangeInfo) {
  const contentText = dataArray.map(row =>
    `Row ${row.rowNumber}: ${row.data.filter(val => val !== '').join(' | ')}`
  ).join('\n');

  return `${userPrompt}\n\n${rangeInfo}\n\n‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå:\n${contentText}`;
}

function performCalculations(dataArray, analysis) {
  const calculations = { summary: {}, groups: {}, totals: {} };

  try {
    analysis.numberColumns.forEach(numCol => {
      const values = dataArray
        .map(row => row.data[numCol.index])
        .filter(val => isNumeric(val))
        .map(val => parseFloat(String(val).replace(/,/g, '')));
      calculations.totals[`column_${numCol.index}`] = {
        sum: values.reduce((sum, val) => sum + val, 0),
        count: values.length
      };
    });

    analysis.categoryColumns.forEach(catCol => {
      analysis.numberColumns.forEach(numCol => {
        const groupKey = `${catCol.index}_to_${numCol.index}`;
        const groups = {};

        dataArray.forEach(row => {
          const category = row.data[catCol.index];
          const value = row.data[numCol.index];
          if (category && isNumeric(value)) {
            if (!groups[category]) groups[category] = [];
            groups[category].push(parseFloat(String(value).replace(/,/g, '')));
          }
        });

        const groupSummaries = {};
        Object.keys(groups).forEach(category => {
          const values = groups[category];
          groupSummaries[category] = {
            sum: values.reduce((sum, val) => sum + val, 0),
            count: values.length
          };
        });

        calculations.groups[groupKey] = groupSummaries;
      });
    });

  } catch (e) {
    Logger.log('Error in calculations: ' + e.message);
    calculations.error = 'Could not complete all calculations';
  }

  return calculations;
}

function formatMixedData(dataArray, calculations, userPrompt, rangeInfo) {
  const rawDataText = dataArray.map(row => `Row ${row.rowNumber}: ${row.data.join(', ')}`).join('\n');

  let calculationsText = '\n‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì (Pre-calculated Results):\n';

  if (Object.keys(calculations.totals).length > 0) {
    calculationsText += '\n‡∏ú‡∏•‡∏£‡∏ß‡∏°‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå:\n';
    Object.entries(calculations.totals).forEach(([key, data]) => {
      calculationsText += `- ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå ${key}: ‡∏£‡∏ß‡∏° ${data.sum.toLocaleString()} ‡∏à‡∏≤‡∏Å ${data.count} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n`;
    });
  }

  if (Object.keys(calculations.groups).length > 0) {
    calculationsText += '\n‡∏ú‡∏•‡∏£‡∏ß‡∏°‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Å‡∏•‡∏∏‡πà‡∏°:\n';
    Object.entries(calculations.groups).forEach(([groupKey, groupData]) => {
      calculationsText += `\n‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏° ${groupKey}:\n`;
      Object.entries(groupData).forEach(([category, data]) => {
        calculationsText += `- ${category}: ‡∏£‡∏ß‡∏° ${data.sum.toLocaleString()} ‡∏à‡∏≤‡∏Å ${data.count} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n`;
      });
    });
  }

  return `${userPrompt}\n\n${rangeInfo}\n\n‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡∏¥‡∏ö:\n${rawDataText}${calculationsText}\n\n‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á: ‡πÉ‡∏ä‡πâ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡πâ‡∏≤‡∏á‡∏ï‡πâ‡∏ô‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏•‡∏∞‡∏ï‡∏≠‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥`;
}

function processRealUniverseTurbo(userPrompt, presetName, temperature) {
  const reduceSystemMessage = getRealUniverseSystemMessage(getDynamicPresetSystemMessage(presetName, 'action'), 'action');
  const config = MODEL_CONFIG.action_turbo;

  const rangeList = SpreadsheetApp.getActiveRangeList();
  if (!rangeList) throw new Error('No cells selected.');

  const ranges = rangeList.getRanges();
  const firstRange = ranges[0];
  const sheetName = firstRange.getSheet().getName();
  const rangeNotation = ranges.map(r => r.getA1Notation()).join(', ');

  let allDataLines = [];

  ranges.forEach(range => {
    const visibleValuesAndRows = getVisibleCellsForActionWithRowNumbers(range);
    visibleValuesAndRows.forEach(item => {
      const processedRow = item.data.map(val => cleanCellData(val)).filter(val => val !== '').join(', ');
      if (processedRow) allDataLines.push(`Row ${item.rowNumber}: ${processedRow}`);
    });
  });

  const totalRowsVisible = allDataLines.length;
  const totalCols = firstRange.getNumColumns();
  const rangeInfo = `Selected Range: ${sheetName}!${rangeNotation} (${totalCols} columns, ${totalRowsVisible} visible rows)`;

  if (totalRowsVisible > MAX_TOTAL_ROWS_TURBO)
    throw new Error('‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà‡∏°‡∏≠‡∏á‡πÄ‡∏´‡πá‡∏ô‡πÑ‡∏î‡πâ‡πÄ‡∏Å‡∏¥‡∏ô‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î: ' + totalRowsVisible + ' > ' + MAX_TOTAL_ROWS_TURBO);

  const mapSystemMessage =
    'data analysis assistant specializing in processing large datasets in chunks.\n' +
    'DATA CONTEXT: ' + rangeInfo + '\n' +
    'USER REQUEST: "' + userPrompt + '"\n' +
    'Extract and summarize information from data chunks relevant to the user request.\n' +
    'Data format: Row <number>: value1, value2, value3\n' +
    'Return JSON format: { "row": "<start-end>", "chunk": <number>, "summary": "<focused_summary>" }\n' +
    'Requirements:\n- Summary in Thai\n- 700-800 words\n- Focus only on relevant information';

  const dataChunks = chunkDataByCharLimit(allDataLines, TURBO_CHUNK_CHAR_LIMIT_ACTION);
  const summaries = [];

  for (let i = 0; i < dataChunks.length; i++) {
    const chunk = dataChunks[i];
    if (!chunk || chunk.trim() === '') continue;

    const chunkRowCount = chunk.split('\n').length;

    const payload = {
      model: config.model,
      messages: [
        { role: 'system', content: mapSystemMessage },
        { role: 'user', content: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡πà‡∏ß‡∏ô‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå: "' + userPrompt + '"\nChunk ' + (i + 1) + '/' + dataChunks.length + ' (' + chunkRowCount + ' rows):\n' + chunk }
      ],
      temperature: temperature,
      max_tokens: 4096,
      response_format: { "type": "json_object" }
    };

    try {
      const result = makeRealUniverseApiCallWithRetry(payload);
      const summary = JSON.parse(result);
      summaries.push(summary);
    } catch (e) {
      summaries.push({ row: (i + 1).toString(), chunk: i + 1, summary: 'Failed to process chunk' });
    }
  }

  const combinedSummaries = JSON.stringify(summaries, null, 2);
  const finalContent = 'Based on these summaries:\n\n' + combinedSummaries + '\n\nAnswer the user request: "' + userPrompt + '"';

  const finalSystemMessage = reduceSystemMessage + '\n\nADDITIONAL CONTEXT: You are analyzing summaries from multiple data chunks. Combine insights from all chunks to create a comprehensive big picture analysis.\n\nRESPONSE REQUIREMENTS:\n- Provide detailed analysis with specific examples and numbers\n- Answer must be between 1000-1500 words\n- Include comprehensive insights from all data chunks\n\n- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏≠‡∏ö‡∏î‡πâ‡∏ß‡∏¢ "ü§ì ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ [‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á]" ‡πÅ‡∏•‡∏∞‡∏à‡∏ö‡∏î‡πâ‡∏ß‡∏¢ "‡∏´‡∏ß‡∏±‡∏á‡∏ß‡πà‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏ï‡∏≠‡∏ö‡πÇ‡∏à‡∏ó‡∏¢‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ô‡∏∞‡∏Ñ‡∏£‡∏±‡∏öüòä"';

  const finalPayload = {
    model: config.model,
    messages: [
      { role: 'system', content: finalSystemMessage },
      { role: 'user', content: finalContent }
    ],
    temperature: temperature,
    max_tokens: config.max_tokens
  };

  const result = makeRealUniverseApiCallWithRetry(finalPayload);
  saveRealUniverseHistory(userPrompt + ' (Turbo)', result);
  return result;
}

function parseThinkingResponse(rawResponse) {
  try {
    let cleanedResponse = rawResponse.trim();
    if (cleanedResponse.startsWith('```json')) {
      cleanedResponse = cleanedResponse.replace(/^```json\s*/, '').replace(/\s*```$/, '');
    } else if (cleanedResponse.startsWith('```')) {
      cleanedResponse = cleanedResponse.replace(/^```\s*/, '').replace(/\s*```$/, '');
    }

    const parsed = JSON.parse(cleanedResponse);

    if (parsed.thinking && Array.isArray(parsed.thinking) && parsed.thinking.length > 0) {
      return {
        thinking: parsed.thinking.slice(0, 15),
        answer: parsed.answer || null
      };
    }

    return {
      thinking: null,
      answer: parsed.answer || rawResponse
    };

  } catch (e) {
    Logger.log('Error parsing thinking response: ' + e.message);
    Logger.log('Raw response: ' + rawResponse);
    
    return {
      thinking: null,
      answer: rawResponse
    };
  }
}

function getSheetRowMetadata(sheet) {
  const spreadsheetId = SpreadsheetApp.getActiveSpreadsheet().getId();
  const sheetName = sheet.getName();
  try {
    const response = Sheets.Spreadsheets.get(spreadsheetId, {
      ranges: [sheetName],
      fields: 'sheets.properties,sheets.data.rowMetadata'
    });
    const sheetData = response.sheets && response.sheets.length > 0 ? response.sheets[0] : null;
    return sheetData && sheetData.data && sheetData.data.length > 0 ? sheetData.data[0].rowMetadata : [];
  } catch (e) {
    Logger.log('Error fetching sheet row metadata from Sheets API: ' + e.message);
    return [];
  }
}

function hasHiddenRowsInRange(range) {
  const sheet = range.getSheet();
  const rowMetadata = getSheetRowMetadata(sheet);

  if (!rowMetadata || rowMetadata.length === 0) {
    const filter = sheet.getFilter();
    if (!filter) return false;
    const startRow = range.getRow();
    const numRows = range.getNumRows();
    try {
      for (let i = 0; i < numRows; i++) {
        const actualRowNumber = startRow + i;
        if (sheet.isRowHiddenByFilter(actualRowNumber) || sheet.isRowHiddenByUser(actualRowNumber)) {
          return true;
        }
      }
    } catch (e) {
      Logger.log('Fallback check for hidden rows failed: ' + e.message);
      return false;
    }
    return false;
  }

  const startRow = range.getRow();
  const numRows = range.getNumRows();

  for (let i = 0; i < numRows; i++) {
    const actualRowIndexInMetadata = startRow + i - 1;
    if (actualRowIndexInMetadata >= 0 && actualRowIndexInMetadata < rowMetadata.length) {
      if (rowMetadata[actualRowIndexInMetadata].hiddenByFilter || rowMetadata[actualRowIndexInMetadata].hiddenByUser) {
        return true;
      }
    }
  }
  return false;
}

function convertToScatteredSelection(range) {
  const sheet = range.getSheet();
  const startRow = range.getRow();
  const numRows = range.getNumRows();

  let visibleCells = [];
  const allValuesInSelectedRange = range.getValues();
  const rowMetadata = getSheetRowMetadata(sheet);

  for (let i = 0; i < numRows; i++) {
    const actualRowNumber = startRow + i;
    const actualRowIndexInMetadata = actualRowNumber - 1;

    if (actualRowIndexInMetadata >= 0 && actualRowIndexInMetadata < rowMetadata.length &&
        !(rowMetadata[actualRowIndexInMetadata].hiddenByFilter || rowMetadata[actualRowIndexInMetadata].hiddenByUser)) {

      const rowData = allValuesInSelectedRange[i];
      const cleanedCells = rowData.map(val => cleanCellData(val)).filter(val => val !== '');
      const processedRow = cleanedCells.join(' | ');
      if (processedRow !== '') visibleCells.push({ rowNumber: actualRowNumber, data: processedRow });
    }
  }

  return visibleCells;
}

function getVisibleCellsOnly(ranges) {
  let visibleData = [];

  ranges.forEach(range => {
    if (hasHiddenRowsInRange(range)) {
      const scatteredCells = convertToScatteredSelection(range);
      visibleData = visibleData.concat(scatteredCells);
    } else {
      const values = range.getValues();
      const startRow = range.getRow();

      values.forEach((row, rowIndex) => {
        const actualRowNumber = startRow + rowIndex;
        const cleanedCells = row.map(cellValue => cleanCellData(cellValue)).filter(cleanValue => cleanValue !== '');
        const processedRow = cleanedCells.join(' | ');
        if (processedRow !== '') visibleData.push({ rowNumber: actualRowNumber, data: processedRow });
      });
    }
  });

  return visibleData;
}

function getVisibleCellsForActionWithRowNumbers(range) {
  const sheet = range.getSheet();
  const rowMetadata = getSheetRowMetadata(sheet);

  let hasActiveFilterOrHiddenRows = false;
  if (rowMetadata && rowMetadata.length > 0) {
    for (let i = 0; i < rowMetadata.length; i++) {
      if (rowMetadata[i].hiddenByFilter || rowMetadata[i].hiddenByUser) {
        hasActiveFilterOrHiddenRows = true;
        break;
      }
    }
  }

  const startRow = range.getRow();
  const numRows = range.getNumRows();
  const allValuesInSelectedRange = range.getValues();

  let visibleRowsAndNumbers = [];

  if (!hasActiveFilterOrHiddenRows) {
    for (let i = 0; i < numRows; i++) {
      visibleRowsAndNumbers.push({
        data: allValuesInSelectedRange[i],
        rowNumber: startRow + i
      });
    }
    return visibleRowsAndNumbers;
  }

  for (let i = 0; i < numRows; i++) {
    const actualRowNumber = startRow + i;
    const actualRowIndexInMetadata = actualRowNumber - 1;

    if (actualRowIndexInMetadata >= 0 && actualRowIndexInMetadata < rowMetadata.length &&
        !(rowMetadata[actualRowIndexInMetadata].hiddenByFilter || rowMetadata[actualRowIndexInMetadata].hiddenByUser)) {
      visibleRowsAndNumbers.push({
        data: allValuesInSelectedRange[i],
        rowNumber: actualRowNumber
      });
    }
  }
  return visibleRowsAndNumbers;
}

function processRealUniverseArray(prompt, preset, temperature) {
  try {
    const systemMessage = getRealUniverseSystemMessage(getDynamicPresetSystemMessage(preset, 'array'), 'array');
    const config = MODEL_CONFIG.array;
    const rangeList = SpreadsheetApp.getActiveRangeList();
    if (!rangeList) return [['‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏ã‡∏•‡∏•‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å']];

    const ranges = rangeList.getRanges();
    if (ranges.length === 0) return [['‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå']];

    const ui = SpreadsheetApp.getUi();
    const userResponse = ui.prompt("‡∏£‡∏∞‡∏ö‡∏∏‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå (‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£ ‡πÄ‡∏ä‡πà‡∏ô D):");
    if (userResponse.getSelectedButton() !== ui.Button.OK) return [['‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô']];

    const targetCol = convertToColumnNumber(userResponse.getResponseText());
    if (!targetCol || isNaN(targetCol)) {
      ui.alert("‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á");
      return [['‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á']];
    }

    let sheetRef = ranges[0].getSheet();

    let allRowsData = getVisibleCellsOnly(ranges);

    if (allRowsData.length === 0) return [['‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå']];
    if (allRowsData.length > MAX_TOTAL_ROWS_ARRAY) {
      return [['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏ñ‡∏ß‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ (‡πÄ‡∏Å‡∏¥‡∏ô ' + MAX_TOTAL_ROWS_ARRAY + ' ‡πÅ‡∏ñ‡∏ß)']];
    }

    const batchSize = Math.min(MAX_ROWS_PER_BATCH_ARRAY, allRowsData.length);
    const numBatches = Math.ceil(allRowsData.length / batchSize);
    const allResults = new Array(allRowsData.length).fill('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÑ‡∏î‡πâ');

    for (let batchIndex = 0; batchIndex < numBatches; batchIndex++) {
      const startIndex = batchIndex * batchSize;
      const endIndex = Math.min(startIndex + batchSize, allRowsData.length);
      const currentBatch = allRowsData.slice(startIndex, endIndex);

      const batchDataForAI = currentBatch.map(item => '‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà ' + item.rowNumber + ': ' + item.data).join('\n');

      const enhancedSystemMessage = systemMessage + '\n\nReturn JSON array format: [{"row": <number>, "result": "<analysis_result>"}]\nMust have exactly ' + currentBatch.length + ' results.';

      const content = prompt + '\n\n‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå:\n' + batchDataForAI + '\n\nReturn JSON array with ' + currentBatch.length + ' results.';

      const payload = {
        model: config.model,
        messages: [
          { role: 'system', content: enhancedSystemMessage },
          { role: 'user', content: content }
        ],
        temperature: temperature,
        max_tokens: config.max_tokens
      };

      try {
        const rawResult = makeRealUniverseApiCall(payload);
        let cleanedResponse = rawResult.trim();

        if (cleanedResponse.startsWith('```json')) {
          cleanedResponse = cleanedResponse.replace(/^```json\s*/, '').replace(/\s*```$/, '');
        }

        const batchResults = JSON.parse(cleanedResponse);

        batchResults.forEach(item => {
          const originalItemIndex = allRowsData.findIndex(data => data.rowNumber === item.row);
          if (originalItemIndex !== -1) {
            allResults[originalItemIndex] = item.result || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÑ‡∏î‡πâ';
          }
        });

      } catch (e) {
        currentBatch.forEach(item => {
          const originalItemIndex = allRowsData.findIndex(data => data.rowNumber === item.rowNumber);
          if (originalItemIndex !== -1) {
            allResults[originalItemIndex] = '‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏î‡πâ';
          }
        });
        Logger.log(`Error processing batch: ${e.message}`);
      }

      currentBatch.forEach(item => {
        const originalItemIndex = allRowsData.findIndex(data => data.rowNumber === item.rowNumber);
        if (originalItemIndex !== -1) {
          try {
            const targetCell = sheetRef.getRange(item.rowNumber, targetCol, 1, 1);
            targetCell.setValue(allResults[originalItemIndex]);
          } catch (e) {
            Logger.log('Error writing to cell ' + item.rowNumber + ', ' + targetCol + ': ' + e.message);
          }
        }
      });

      SpreadsheetApp.flush();
      if (batchIndex < numBatches - 1) Utilities.sleep(500);
    }

    return [['‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ñ‡∏π‡∏Å‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÉ‡∏ô‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏£‡∏∞‡∏ö‡∏∏ (‡∏à‡∏≥‡∏ô‡∏ß‡∏ô ' + allRowsData.length + ' ‡πÅ‡∏ñ‡∏ß)']];

  } catch (error) {
    Logger.log('Error in processRealUniverseArray: ' + error.toString());
    return [['‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.toString()]];
  }
}

function processRealUniverseImage(prompt, preset, temperature) {
  try {
    const config = MODEL_CONFIG.image;

    let contextData = '';
    const rangeList = SpreadsheetApp.getActiveRangeList();
    if (rangeList) {
      const ranges = rangeList.getRanges();
      ranges.forEach(range => {
        const values = range.getValues();
        values.forEach(row => {
          const cellText = row.filter(cell => cell !== '').join(' ');
          if (cellText) contextData += cellText + ' ';
        });
      });
    }

    const promptTemplate = getRealUniverseSystemMessage(getDynamicPresetSystemMessage(preset, 'image'), 'image');

    const analysisPayload = {
      model: 'gpt-4.1',
      messages: [
        { role: 'system', content: promptTemplate },
        { role: 'user', content: `‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á detailed prompt ‡∏à‡∏≤‡∏Å‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤: "${contextData.trim()}"` }
      ],
      temperature: temperature,
      max_tokens: 2000
    };

    const detailedPrompt = makeRealUniverseApiCall(analysisPayload);

    const imagePayload = {
      model: config.model,
      prompt: detailedPrompt,
      size: config.size,
      quality: config.quality,
      n: config.n
    };

    const result = makeRealUniverseImageApiCall(imagePayload);

    const combinedPrompt = contextData ? `${prompt}: ${contextData.trim()}` : prompt;

    const downloadUrl = insertImageToSheet(result.imageUrl, combinedPrompt);

    if (downloadUrl) {
      const message = `üé® ‡∏†‡∏≤‡∏û‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!\n\nüì• ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î: ${downloadUrl}`;
      saveRealUniverseHistory(prompt + ' (Smart Image)', message);
      return message;
    } else {
      throw new Error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏ó‡∏£‡∏Å‡∏†‡∏≤‡∏û‡πÉ‡∏ô‡∏ä‡∏µ‡∏ï‡πÑ‡∏î‡πâ');
    }

  } catch (error) {
    Logger.log('Error in processRealUniverseImage: ' + error.toString());
    return '‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û: ' + error.toString();
  }
}

/* ------------------ API AND HELPER FUNCTIONS ------------------ */

function getApiTypeForModel(modelName) {
  if (!modelName) return 'chat';
  const m = String(modelName).toLowerCase();

  const isGpt5 = m.startsWith('gpt-5');
  const isCodexMini = m.includes('codex-mini');
  const isOseries = m.startsWith('o');
  const isGpt5Codex = m.includes('gpt-5-codex');

  if (isGpt5 || isCodexMini || isOseries || isGpt5Codex) return 'responses';
  return 'chat';
}

function buildRequestBodyForApi(apiType, payload) {
  const { model, messages, temperature, max_tokens, response_format } = payload || {};
  if (apiType === 'responses') {
    const body = {
      model: model,
      input: messages
    };
    if (typeof max_tokens !== 'undefined') {
      body.max_output_tokens = max_tokens;
    }
    if (response_format) {
      body.response_format = response_format;
    }
    return body;
  } else {
    const body = {
      model: model,
      messages: messages
    };
    if (typeof temperature !== 'undefined') {
      body.temperature = temperature;
    }
    if (typeof max_tokens !== 'undefined') {
      body.max_tokens = max_tokens;
    }
    if (response_format) {
      body.response_format = response_format;
    }
    return body;
  }
}

function extractTextFromApiResponse(apiType, resJson) {
  try {
    if (apiType === 'responses') {
      if (typeof resJson.output_text === 'string' && resJson.output_text.trim() !== '') {
        return resJson.output_text.trim();
      }
      if (Array.isArray(resJson.output)) {
        const texts = [];
        resJson.output.forEach(part => {
          if (part && Array.isArray(part.content)) {
            part.content.forEach(c => {
              if (c && typeof c.text === 'string') texts.push(c.text);
            });
          }
        });
        if (texts.length) return texts.join('').trim();
      }
      if (Array.isArray(resJson.content)) {
        const texts = [];
        resJson.content.forEach(c => {
          if (c && typeof c.text === 'string') texts.push(c.text);
          if (c && Array.isArray(c.content)) {
            c.content.forEach(cc => {
              if (cc && typeof cc.text === 'string') texts.push(cc.text);
            });
          }
        });
        if (texts.length) return texts.join('').trim();
      }
      return JSON.stringify(resJson);
    } else {
      if (resJson && resJson.choices && resJson.choices[0] && resJson.choices[0].message) {
        const out = resJson.choices[0].message.content;
        if (typeof out === 'string') return out.trim();
      }
      return JSON.stringify(resJson);
    }
  } catch (e) {
    Logger.log('extractTextFromApiResponse error: ' + e.message);
    return JSON.stringify(resJson);
  }
}

function makeRealUniverseApiCall(payload) {
  const apiKey = PropertiesService.getScriptProperties().getProperty('REALUNIVERSE_API_KEY');
  if (!apiKey) throw new Error('API Key not set. Please use the menu to set it up.');

  const apiType = getApiTypeForModel(payload && payload.model);
  const endpoint = apiType === 'responses' ? RESPONSES_API_URL : API_URL;
  const requestBody = buildRequestBodyForApi(apiType, payload);

  const options = {
    method: 'POST',
    contentType: 'application/json',
    headers: { 'Authorization': 'Bearer ' + apiKey },
    payload: JSON.stringify(requestBody),
    muteHttpExceptions: true
  };

  const response = UrlFetchApp.fetch(endpoint, options);
  const status = response.getResponseCode();
  const bodyText = response.getContentText();
  let res;
  try {
    res = JSON.parse(bodyText);
  } catch (err) {
    throw new Error('API Response parse error: ' + bodyText);
  }

  if (status >= 400) {
    const errMsg = res && res.error && res.error.message ? res.error.message : bodyText;
    throw new Error('API Error: ' + errMsg);
  }

  const text = extractTextFromApiResponse(apiType, res);
  if (!text || !String(text).trim()) {
    throw new Error('Invalid response from AI.');
  }
  return String(text).trim();
}

function makeRealUniverseApiCallWithRetry(payload, maxRetries = 2) {
  let lastError;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return makeRealUniverseApiCall(payload);
    } catch (error) {
      lastError = error;
      Logger.log(`API call attempt ${attempt + 1} failed: ${error.message}`);

      if (attempt < maxRetries) {
        const delayMs = Math.pow(2, attempt) * 1000;
        Utilities.sleep(delayMs);
      }
    }
  }

  throw new Error(`API call failed after ${maxRetries + 1} attempts. Last error: ${lastError.message}`);
}

function makeRealUniverseImageApiCall(payload) {
  const apiKey = PropertiesService.getScriptProperties().getProperty('REALUNIVERSE_API_KEY');
  if (!apiKey) throw new Error('API Key not set. Please use the menu to set it up.');

  const options = {
    method: 'POST',
    contentType: 'application/json',
    headers: { 'Authorization': 'Bearer ' + apiKey },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  const response = UrlFetchApp.fetch(IMAGE_API_URL, options);
  const res = JSON.parse(response.getContentText());

  if (response.getResponseCode() >= 400) {
    throw new Error('Image API Error: ' + (res.error ? res.error.message : response.getContentText()));
  }

  if (!res.data || !res.data[0] || !res.data[0].url) {
    throw new Error('Invalid response from Image API.');
  }

  return {
    imageUrl: res.data[0].url,
    revisedPrompt: res.data[0].revised_prompt || payload.prompt
  };
}

function insertImageToSheet(imageUrl, description) {
  try {
    const response = UrlFetchApp.fetch(imageUrl);
    let blob = response.getBlob();

    blob = Utilities.newBlob(
      blob.getBytes(),
      'image/jpeg',
      'resized_image.jpg'
    );

    let folder;
    const folders = DriveApp.getFoldersByName('RealUniverse Images');
    if (folders.hasNext()) {
      folder = folders.next();
    } else {
      folder = DriveApp.createFolder('RealUniverse Images');
    }

    const file = folder.createFile(blob.setName('RealUniverse_' + new Date().getTime() + '.jpg'));

    const thumbnailBlob = blob.setName('thumb_' + new Date().getTime() + '.jpg');

    const sheet = SpreadsheetApp.getActiveSheet();
    sheet.insertImage(thumbnailBlob, 1, 3);

    return file.getUrl();

  } catch (error) {
    Logger.log('Error: ' + error.toString());
    return false;
  }
}

function getRealUniverseSystemMessage(cellReference, mode) {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Preset');

  if (!sheet) {
    throw new Error('‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö Sheet "Preset" ‡πÇ‡∏õ‡∏£‡∏î‡∏™‡∏£‡πâ‡∏≤‡∏á Sheet ‡∏ä‡∏∑‡πà‡∏≠ "Preset" ‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô');
  }

  try {
    if (cellReference.includes('Preset!')) {
      const cellAddr = cellReference.split('!')[1];
      const value = sheet.getRange(cellAddr).getValue();
      if (value && String(value).trim()) {
        return String(value).trim();
      } else {
        throw new Error(`‚ùå ‡πÄ‡∏ã‡∏•‡∏•‡πå ${cellReference} ‡πÉ‡∏ô Sheet "Preset" ‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤`);
      }
    }
  } catch (e) {
    if (e.message.includes('‚ùå')) throw e;
    throw new Error('‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô Sheet "Preset": ' + e.message);
  }

  if (mode === 'array') {
    return 'You are an AI that analyzes data and returns results in JSON format. For each row of input data, provide a JSON object in the format {"row": <row_number>, "result": "<analysis_result>"}. Return an array of these objects.';
  } else if (mode === 'image') {
    return 'Create a detailed image based on this description: {prompt}';
  } else {
    return 'You are a helpful AI assistant that analyzes spreadsheet data and provides insights in Thai language.';
  }
}

function chunkDataByCharLimit(lines, charLimit) {
  if (!lines || lines.length === 0) return [];

  const chunks = [];
  let currentChunkLines = [];
  let currentCharCount = 0;

  for (const line of lines) {
    const processedLine = line.trim() === '' ? '(‡πÅ‡∏ñ‡∏ß‡∏ß‡πà‡∏≤‡∏á)' : line;
    const lineLength = processedLine.length + 1;

    if (currentCharCount + lineLength > charLimit && currentChunkLines.length > 0) {
      chunks.push(currentChunkLines.join('\n'));
      currentChunkLines = [processedLine];
      currentCharCount = lineLength;
    } else {
      currentChunkLines.push(processedLine);
      currentCharCount += lineLength;
    }
  }

  if (currentChunkLines.length > 0) {
    chunks.push(currentChunkLines.join('\n'));
  }

  return chunks;
}

function cleanCellData(cellValue) {
  if (cellValue == null || cellValue === '') return '';

  return String(cellValue)
    .replace(/[\x00-\x1F\x7F-\x9F\u200B-\u200D\uFEFF]/g, '')
    .replace(/[\r\n]+/g, ' ')
    .replace(/[|:]/g, ' ')
    .replace(/&[a-zA-Z0-9#]+;/g, ' ')
    .replace(/["""'']/g, '"')
    .replace(/\s+/g, ' ')
    .trim()
    .replace(/^["']|["']$/g, '');
}

function convertToColumnNumber(input) {
  input = String(input).toUpperCase().trim();
  if (!isNaN(input) && Number(input) > 0) return parseInt(input, 10);
  let result = 0;
  for (let i = 0; i < input.length; i++) {
    result = result * 26 + (input.charCodeAt(i) - 'A'.charCodeAt(0) + 1);
  }
  return result > 0 ? result : null;
}

/* ------------------ UTILITY FUNCTIONS ------------------ */

function saveRealUniverseHistory(question, answer) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let sheet = ss.getSheetByName(CHAT_SHEET_NAME);
    if (!sheet) {
      sheet = ss.insertSheet(CHAT_SHEET_NAME);
      sheet.getRange('A1:D1').setValues([['Timestamp', 'Question', 'Answer', 'Selected Cells']]).setFontWeight('bold');
    }
    const selection = getRealUniverseSelectedCellInfo();
    sheet.appendRow([new Date(), question, String(answer), selection]);
  } catch (e) {
    Logger.log('Error saving history: ' + e.message);
  }
}

function clearRealUniverseHistory() {
  const ui = SpreadsheetApp.getUi();
  const response = ui.alert('Confirm Clear', 'Clear all chat history?', ui.ButtonSet.YES_NO);
  if (response === ui.Button.YES) {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(CHAT_SHEET_NAME);
    if (sheet) {
      sheet.clearContents().getRange('A1:D1')
        .setValues([['Timestamp', 'Question', 'Answer', 'Selected Cells']])
        .setFontWeight('bold');
      ui.alert('Success', 'Chat history cleared.', ui.ButtonSet.OK);
    }
  }
}

function getRealUniverseSelectedCellInfo() {
  try {
    const rangeList = SpreadsheetApp.getActiveSpreadsheet().getActiveRangeList();
    if (rangeList) {
      const ranges = rangeList.getRanges();
      const sheetName = ranges[0].getSheet().getName();
      if (ranges.length > 1) {
        return sheetName + '!' + ranges.map(r => r.getA1Notation()).join(', ');
      } else if (ranges.length === 1) {
        const r = ranges[0];
        return sheetName + '!' + r.getA1Notation() + ' (' + r.getNumRows() + ' rows, ' + r.getNumColumns() + ' cols)';
      }
    }
    return '(No cells selected)';
  } catch (e) {
    return '(Error reading selection)';
  }
}

/**
 * Generate the complete HTML content for the AI interface
 */
function getRealUniverseHtmlContent() {
  return `<!DOCTYPE html>
<html lang="th">
<head>
<base target="_top">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RealUniverse AI</title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    background: #f5f5f7;
    height: 100vh;
    width: 100vw;     
    margin: 0;        
    padding: 0;      
    overflow: hidden;
}
.container {
    height: 100%;
    width: 100%;      
    display: flex;
    flex-direction: column;
    background: white;
    position: relative;
}
.mode-switch-button {
    position: absolute;
    top: 8px;
    right: 8px;
    background: transparent;
    border: none;
    color: #86868b;
    font-size: 12px;
    cursor: pointer;
    padding: 6px 8px;
    border-radius: 6px;
    outline: none;
    transition: all 0.2s ease;
    z-index: 1000;
    display: flex;
    align-items: center;
    gap: 4px;
}
.mode-switch-button:hover {
    color: #1d1d1f;
    background: #f8f9fa;
}
.chat-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}
.messages {
    flex: 1;
    overflow-y: auto;
    padding: 16px 12px;
    background: #F0FFFF;
    scroll-behavior: smooth;
}
.message {
    margin-bottom: 12px;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    position: relative;
}
.message.user {
    align-items: flex-end;
}

/* ‚≠ê Thinking Box Styles */
.thinking-box {
    background: #f8f9fa;
    border: 1px solid #e5e5e7;
    border-radius: 12px;
    padding: 12px;
    margin-bottom: 8px;
    max-width: 85%;
    font-size: 10px;
}
.thinking-header {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 11px;
    font-weight: 600;
    color: #1d1d1f;
    margin-bottom: 8px;
}
.thinking-steps {
    display: flex;
    flex-direction: column;
    gap: 6px;
}
.thinking-step {
    padding: 4px 0 4px 8px;
    border-left: 2px solid #8360c3;
    color: #424245;
    line-height: 1.6;
    opacity: 0;
    transform: translateY(-5px);
}

.message-content {
    max-width: 100%;
    padding: 10px 14px;
    border-radius: 18px;
    font-size: 12px;
    line-height: 1.3;
    word-wrap: break-word;
    word-break: break-word;
    white-space: pre-wrap;
    position: relative;
}
.message.user .message-content {
    background: #E6E6FA;
    color: #1d1d1f;
    border-bottom-right-radius: 4px;
}
.message.bot .message-content {
    background: #F0FFFF;
    color: #1d1d1f;
    border-bottom-left-radius: 4px;
}
.message-content strong {
    font-weight: 600;
    color: #1d1d1f;
}

/* Copy Button Styles */
.copy-button {
    position: absolute;
    bottom: 4px;
    right: 4px;
    background: transparent;
    border: none;
    border-radius: 4px;
    width: 26px;
    height: 26px;
    cursor: pointer;
    display: none;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    color: #86868b;
    transition: all 0.2s ease;
    z-index: 10;
}
.copy-button:hover {
    background: transparent;
    color: #1d1d1f;
}
.copy-button.copied {
    background: transparent;
    color: #059669;
}
.message.bot.typing-finished .copy-button {
    display: flex;
}

/* Tooltip Styles */
.tooltip {
    position: relative;
}
.tooltip:hover::after {
    content: attr(data-tooltip);
    position: absolute;
    bottom: calc(100% + 8px);
    left: 50%;
    transform: translateX(-50%);
    background: #1d1d1f;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 10px;
    white-space: nowrap;
    z-index: 1000;
    opacity: 1;
    pointer-events: none;
}
.tooltip:hover::before {
    content: '';
    position: absolute;
    bottom: calc(100% + 2px);
    left: 50%;
    transform: translateX(-50%);
    border: 4px solid transparent;
    border-top-color: #1d1d1f;
    z-index: 1000;
    opacity: 1;
    pointer-events: none;
}

.input-area {
    background: #F0FFFF;
    padding: 16px 16px 0 16px;
    display: flex;
    flex-direction: column;
    align-items: center;
    position: relative;
}

/* Sidebar Mode */
.sidebar-mode .expanded-input-container {
    max-width: none;
    width: 100%;
}
.sidebar-mode .turbo-wrapper {
    max-width: none;
    width: 100%;
}
.sidebar-mode .quick-actions-buttons {
    flex-direction: row;
    justify-content: center;
    align-items: center;
    gap: 6px;
    flex-wrap: wrap;
}
.sidebar-mode .quick-action-btn {
    border-radius: 12px;
    text-align: center;
    flex: none;
}
.sidebar-mode .in-box-controls {
    flex-wrap: wrap;
    gap: 4px;
}
.sidebar-mode .status-text {
    font-size: 9px;
    padding: 3px 6px;
}
.sidebar-mode .turbo-toggle {
    font-size: 9px;
    padding: 3px 6px;
}
.sidebar-mode .thinking-toggle {
    font-size: 9px;
    padding: 3px 6px;
}
.sidebar-mode .hamburger-btn {
    padding: 3px 6px;
    font-size: 10px;
}
.sidebar-mode .sendButton {
    width: 28px;
    height: 28px;
}

.custom-title-bar {
    background: #F0FFFF;
    border-bottom: none;
    padding: 12px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: relative;
}
.app-title {
    background: linear-gradient(45deg, #8360c3, #2ebf91, #8360c3);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    font-family: 'Roboto', sans-serif;
    font-weight: 500;
    font-size: 20px;
    letter-spacing: 0.3px;
    margin: 0;
    padding-left: 40px;
    position: relative;
}
.app-title::before {
    content: '';
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 40px;
    height: 40px;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" stroke="%238360c3" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M14.826 5.376c2.8-1.995 5.087-2.882 5.883-2.085c.797.796-.09 3.083-2.085 5.884m-13.248 5.65c-1.995 2.8-2.882 5.088-2.085 5.884c.796.797 3.083-.09 5.884-2.085m9.45-9.45c-1.133 1.59-2.622 3.345-4.364 5.087s-3.497 3.231-5.086 4.363m9.45-9.45A7.2 7.2 0 0 1 19.2 12a7.2 7.2 0 0 1-10.025 6.624M17.09 6.91A7.2 7.2 0 1 0 6.91 17.09" color="%238360c3"/></svg>');
    background-size: contain;
    background-repeat: no-repeat;
}

.turbo-wrapper {
    position: relative;
    width: 100%;
    max-width: 400px;
    display: flex;
    justify-content: flex-start;
    margin-bottom: 4px;
}
.turbo-container {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: 8px;
}
.turbo-toggle {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 4px 8px;
    border-radius: 6px;
    background: transparent;
    border: 1px solid #d1d5db;
    cursor: pointer;
    font-size: 10px;
    color: #86868b;
    outline: none;
    transition: all 0.2s ease;
}
.turbo-toggle.active {
    background: #b3e5fc;
    color: #1d1d1f;
    border-color: #b3e5fc;
}
.turbo-status {
    font-size: 9px;
    color: #86868b;
}

/* ‚≠ê NEW: Thinking Mode Toggle */
.thinking-toggle {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 4px 8px;
    border-radius: 6px;
    background: transparent;
    border: 1px solid #d1d5db;
    cursor: pointer;
    font-size: 10px;
    color: #86868b;
    outline: none;
    transition: all 0.2s ease;
}
.thinking-toggle.active {
    background: #ddd6fe;
    color: #1d1d1f;
    border-color: #8360c3;
}

.send-button {
    background: white;
    color: white;
    border: 2px solid #e5e5e7;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    flex-shrink: 0;
    background-image: url('https://i.ibb.co/vvCrQ8DW/RS.jpg');
    background-size: 26px 26px;
    background-repeat: no-repeat;
    background-position: center;
    transition: all 0.2s ease;
}
.send-button:hover {
    background-color: #f8f9fa;
    border-color: #d1d5db;
    transform: scale(1.05);
}
.send-button:disabled {
    background-color: #f5f5f5;
    background-image: url('https://i.ibb.co/vvCrQ8DW/RS.jpg');
    border-color: #e5e5e7;
    cursor: not-allowed;
    opacity: 0.6;
}
.send-button:disabled.spinning {
    animation: spin 1s linear infinite !important;
    background-color: #f5f5f5 !important;
    background-image: url('https://i.ibb.co/vvCrQ8DW/RS.jpg') !important;
    border-color: #e5e5e7 !important;
    cursor: not-allowed !important;
    opacity: 0.6 !important;
}
@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}
.send-button.spinning {
    animation: spin 1s linear infinite;
}

.expanded-input-container {
    width: 100%;
    max-width: 400px;
    display: flex;
    align-items: stretch;
    background: white;
    border: 1px solid #E6E6FA;
    border-radius: 20px;
    padding: 6px 12px;
    margin-bottom: 8px;
    position: relative;
}

.input-content {
    flex: 1;
    display: flex;
    flex-direction: column;
}

.message-input {
    width: 100%;
    border: none;
    background: transparent;
    padding: 10px 0 0 0;
    font-size: 12px;
    outline: none;
    resize: none;
    max-height: 100px;
    min-height: 24px;
    line-height: 1.4;
    font-family: inherit;
    color: #1d1d1f;
    overflow-y: auto;
    scrollbar-width: none;
}
.message-input::-webkit-scrollbar {
    display: none;
}
.message-input::placeholder {
    color: #86868b;
}

.in-box-controls {
   display: flex;
   align-items: center;
   gap: 8px;
   margin-top: 14px;
   padding: 4px 0 8px 0;
   position: relative;
}

.hamburger-btn {
    background: transparent;
    border: 1px solid #d1d5db;
    color: #86868b;
    cursor: pointer;
    padding: 2px 4px;
    border-radius: 4px;
    font-size: 12px;
    transition: all 0.2s ease;
}
.hamburger-btn:hover {
    background: rgba(255,255,255,0.5);
    color: #1d1d1f;
}

.status-text {
    font-size: 10px;
    color: #86868b;
    border: 1px solid #d1d5db;
    padding: 4px 8px;
    border-radius: 4px;
}

.sendButton {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 1px solid #E6E6FA;
    background: white;
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-left: 8px;
    flex-shrink: 0;
    align-self: flex-end;
    background-image: url('https://i.ibb.co/vvCrQ8DW/RS.jpg');
    background-size: 26px 26px;
    background-repeat: no-repeat;
    background-position: center;
    transition: all 0.2s ease;
}
.sendButton:hover {
    background-color: white;
    transform: scale(1.05);
}
.sendButton:disabled {
    background-color: #f5f5f5;
    background-image: url('https://i.ibb.co/vvCrQ8DW/RS.jpg');
    border-color: #e5e5e7;
    cursor: not-allowed;
    opacity: 0.6;
}
.sendButton:disabled.spinning {
    animation: spin 1s linear infinite !important;
    background-color: #f5f5f5 !important;
    background-image: url('https://i.ibb.co/vvCrQ8DW/RS.jpg') !important;
    border-color: #e5e5e7 !important;
    cursor: not-allowed !important;
    opacity: 0.6 !important;
}
.sendButton.spinning {
    animation: spin 1s linear infinite;
}

.settings-popup {
    position: absolute;
    bottom: calc(100% + 8px);
    left: 0;
    background: white;
    border-radius: 12px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.15);
    padding: 16px;
    width: 320px;
    max-height: 350px;
    overflow-y: auto;
    display: none;
    z-index: 1000;
}
.settings-popup.show {
    display: block;
}
.popup-section {
    margin-bottom: 12px;
}
.popup-title {
    font-size: 12px;
    font-weight: 600;
    color: #1d1d1f;
    margin-bottom: 6px;
}
.popup-options {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
}
.popup-option {
    padding: 4px 8px;
    background: #f8f9fa;
    border: 1px solid #e5e5e7;
    border-radius: 6px;
    font-size: 10px;
    cursor: pointer;
    transition: all 0.2s ease;
}
.popup-option:hover {
    background: #e5e5e7;
}
.popup-option.active {
    background: #8360c3;
    color: white;
    border-color: #8360c3;
}

.array-info {
    background: #F0FFFF;
    padding: 6px 8px;
    border-radius: 4px;
    font-size: 10px;
    color: #0066cc;
    border: 1px solid #F0FFFF;
    margin-top: -4px;
}
.messages::-webkit-scrollbar {
    width: 4px;
}
.messages::-webkit-scrollbar-track {
    background: transparent;
}
.messages::-webkit-scrollbar-thumb {
    background: #c7c7cc;
    border-radius: 4px;
}
.typing-indicator {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 10px 14px;
    background: white;
    border-radius: 18px;
    border-bottom-left-radius: 4px;
}
.typing-dot {
    width: 4px;
    height: 4px;
    border-radius: 50%;
    background: #86868b;
    animation: typing 1.4s infinite;
}
.typing-dot:nth-child(2) {
    animation-delay: 0.2s;
}
.typing-dot:nth-child(3) {
    animation-delay: 0.4s;
}
@keyframes typing {
    0%, 60%, 100% {
        transform: translateY(0);
        opacity: 0.4;
    }
    30% {
        transform: translateY(-4px);
        opacity: 1;
    }
}
.empty-state {
    text-align: center;
    color: #86868b;
    font-size: 14px;
    padding: 0;
    line-height: 1.5;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
}

.quick-actions {
    padding: 8px 16px 12px 16px;
    background: transparent;
}
.quick-actions-label {
    font-size: 11px;
    color: #86868b;
    margin-bottom: 0;
    text-align: center;
    cursor: pointer;
    transition: color 0.2s ease;
}
.quick-actions:hover .quick-actions-buttons {
    opacity: 1;
    max-height: 100px;
    margin-top: 8px;
}
.quick-actions:hover .quick-actions-label {
    color: #1d1d1f;
}
.quick-actions-buttons {
    display: flex;
    justify-content: center;
    gap: 8px;
    flex-wrap: wrap;
    opacity: 0;
    max-height: 0;
    overflow: hidden;
    transition: all 0.3s ease;
}
.quick-action-btn {
    background: #1d1d1f;
    border: 1px solid #1d1d1f;
    border-radius: 16px;
    padding: 3px 7px;
    font-size: 7px;
    color: white;
    cursor: pointer;
    transition: all 0.2s ease;
    outline: none;
    font-family: inherit;
}
.quick-action-btn:hover {
    background: #2d2d2f;
    border-color: #2d2d2f;
    transform: translateY(-1px);
}
.quick-action-btn:active {
    transform: translateY(0);
    background: #0d0d0f;
}
</style>
</head>
<body>
<div class="container" id="main-container">
    <div class="custom-title-bar">
        <div class="app-title">Real Universe Agentic</div>
        <button class="mode-switch-button" id="mode-switch-button" onclick="toggleDisplayMode()">
            ‚ñ¢‚ñ£
        </button>
    </div>
    
    <div class="chat-container">
        <div class="messages" id="messages">
            <div class="empty-state">Intelligent insights for your Google Sheets</div>
        </div>
    </div>

    <div class="input-area">
        <div class="quick-actions" id="quick-actions">
            <div class="quick-actions-label">‚ö°Ô∏èQuick Action</div>
            <div class="quick-actions-buttons">
                <button class="quick-action-btn" onclick="sendQuickAction('‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•')">‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</button>
                <button class="quick-action-btn" onclick="sendQuickAction('‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô')">‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô</button>
                <button class="quick-action-btn" onclick="sendQuickAction('‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏õ‡∏£‡∏∞‡πÄ‡∏î‡πá‡∏ô‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç')">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏õ‡∏£‡∏∞‡πÄ‡∏î‡πá‡∏ô‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç</button>
</div>
        </div>

        <div class="turbo-wrapper">
            <div class="turbo-container">
                <button class="turbo-toggle" id="turbo-toggle" onclick="toggleTurbo()">üí° Deep</button>
                <button class="thinking-toggle" id="thinking-toggle" onclick="toggleThinking()">üß† Thinking</button>
            </div>
        </div>

        <div class="expanded-input-container">
            <div class="input-content">
                <textarea
                    class="message-input"
                    id="messageInput"
                    placeholder="Ask me anything.."
                    rows="1"
                ></textarea>
                
                <div class="in-box-controls">
                    <button class="hamburger-btn" onclick="toggleSettingsPopup()">üëÅ</button>
                    <span class="status-text" id="statusText">Answer ‚Ä¢ Loading... ‚Ä¢ Exact</span>
                </div>
            </div>
            
            <button class="sendButton" id="sendButton" onclick="handleSend()"></button>
        </div>
    </div>

    <div class="settings-popup" id="settingsPopup">
        <div class="popup-section">
            <div class="popup-title">üéØ Mode</div>
            <div class="popup-options" id="modeOptions">
                <div class="popup-option active" data-mode="action">Answer</div>
                <div class="popup-option" data-mode="array">Array</div>
                <div class="popup-option" data-mode="image">Create Picture</div>
            </div>
        </div>
        
        <div class="popup-section" id="actionPresetSection">
            <div class="popup-title">üìã Preset (Answer Mode)</div>
            <div class="popup-options" id="actionPresetOptions"></div>
        </div>
        
        <div class="popup-section" id="arrayPresetSection" style="display: none;">
            <div class="popup-title">üìã Preset (Array Mode)</div>
            <div class="popup-options" id="arrayPresetOptions"></div>
        </div>

        <div class="popup-section" id="imagePresetSection" style="display: none;">
            <div class="popup-title">üé® Preset (Image Mode)</div>
            <div class="popup-options" id="imagePresetOptions"></div>
        </div>
        
        <div class="popup-section" id="temperatureSection">
            <div class="popup-title">üå°Ô∏è Temperature</div>
            <div class="popup-options" id="temperatureOptions">
                <div class="popup-option active" data-temp="0">Exact</div>
                <div class="popup-option" data-temp="0.2">Balanced</div>
                <div class="popup-option" data-temp="0.4">Expressive</div>
                <div class="popup-option" data-temp="0.7">Creative</div>
            </div>
        </div>
    </div>
</div>

<script>
let currentMode = 'action';
let currentPreset = 'action_preset_2';
let currentTemperature = 0;
let turboMode = false;
let thinkingMode = false; // ‚≠ê NEW
let isProcessing = false;
let isTyping = false;
let currentTypingElement = null;
let currentTypingText = '';
let allPresets = { action: {}, array: {}, image: {} };

/**
 * Initialize the app
 */
function init() {
    loadPresets();
    setupEventListeners();
    updateSendButton();
    updateStatusText();
    checkDisplayMode();
}

/**
 * Check and apply display mode
 */
function checkDisplayMode() {
    google.script.run
        .withSuccessHandler(function(mode) {
            const container = document.getElementById('main-container');
            if (mode === 'sidebar') {
                container.classList.add('sidebar-mode');
            } else {
                container.classList.remove('sidebar-mode');
            }
        })
        .getCurrentDisplayMode();
}

/**
 * Toggle display mode
 */
function toggleDisplayMode() {
    google.script.run.toggleDisplayMode();
}

/**
 * Load presets from server
 */
function loadPresets() {
    google.script.run
        .withSuccessHandler(function(presets) {
            allPresets = presets;
            populatePresetOptions('action', presets.action);
            populatePresetOptions('array', presets.array);
            populatePresetOptions('image', presets.image);
            
            const firstActionKey = Object.keys(presets.action)[0];
            if (firstActionKey) currentPreset = firstActionKey;
            
            updateStatusText();
        })
        .withFailureHandler(function(error) {
            console.error('Failed to load presets:', error);
            addMessage('‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î Presets ‡πÑ‡∏î‡πâ: ' + error.message, 'bot');
        })
        .getDynamicPresets();
}

/**
 * Populate preset options in settings popup
 */
function populatePresetOptions(mode, presets) {
    const containerId = mode + 'PresetOptions';
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = '';
    
    Object.keys(presets).forEach((key, index) => {
        const option = document.createElement('div');
        option.className = 'popup-option';
        option.textContent = presets[key].DISPLAY_NAME;
        option.setAttribute('data-preset', key);
        
        if (index === 0 && mode === 'action') {
            option.classList.add('active');
        }
        
        option.onclick = function() {
            const siblings = container.querySelectorAll('.popup-option');
            siblings.forEach(s => s.classList.remove('active'));
            this.classList.add('active');
            currentPreset = key;
            updateStatusText();
        };
        
        container.appendChild(option);
    });
}

/**
 * Setup event listeners
 */
function setupEventListeners() {
    const input = document.getElementById('messageInput');
    
    input.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = Math.min(this.scrollHeight, 100) + 'px';
    });
    
    input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleSend();
        }
    });
    
    const modeOptions = document.querySelectorAll('#modeOptions .popup-option');
    modeOptions.forEach(option => {
        option.onclick = function() {
            modeOptions.forEach(o => o.classList.remove('active'));
            this.classList.add('active');
            
            const mode = this.getAttribute('data-mode');
            currentMode = mode;
            
            document.getElementById('actionPresetSection').style.display = mode === 'action' ? 'block' : 'none';
            document.getElementById('arrayPresetSection').style.display = mode === 'array' ? 'block' : 'none';
            document.getElementById('imagePresetSection').style.display = mode === 'image' ? 'block' : 'none';
            document.getElementById('temperatureSection').style.display = mode === 'image' ? 'none' : 'block';
            
            const turboToggle = document.getElementById('turbo-toggle');
            const thinkingToggle = document.getElementById('thinking-toggle');
            const turboWrapper = document.querySelector('.turbo-wrapper');
            
            if (mode === 'action') {
                turboWrapper.style.display = 'flex';
                const firstActionKey = Object.keys(allPresets.action)[0];
                if (firstActionKey) currentPreset = firstActionKey;
            } else if (mode === 'array') {
                turboWrapper.style.display = 'none';
                turboMode = false;
                thinkingMode = false;
                turboToggle.classList.remove('active');
                thinkingToggle.classList.remove('active');
                const firstArrayKey = Object.keys(allPresets.array)[0];
                if (firstArrayKey) currentPreset = firstArrayKey;
            } else if (mode === 'image') {
                turboWrapper.style.display = 'none';
                turboMode = false;
                thinkingMode = false;
                turboToggle.classList.remove('active');
                thinkingToggle.classList.remove('active');
                const firstImageKey = Object.keys(allPresets.image)[0];
                if (firstImageKey) currentPreset = firstImageKey;
            }
            
            updateStatusText();
        };
    });
    
    const tempOptions = document.querySelectorAll('#temperatureOptions .popup-option');
    tempOptions.forEach(option => {
        option.onclick = function() {
            tempOptions.forEach(o => o.classList.remove('active'));
            this.classList.add('active');
            currentTemperature = parseFloat(this.getAttribute('data-temp'));
            updateStatusText();
        };
    });
    
    document.addEventListener('click', function(e) {
        const popup = document.getElementById('settingsPopup');
        const hamburger = document.querySelector('.hamburger-btn');
        
        if (popup.classList.contains('show') && 
            !popup.contains(e.target) && 
            !hamburger.contains(e.target)) {
            popup.classList.remove('show');
        }
    });
}

/**
 * Toggle settings popup
 */
function toggleSettingsPopup() {
    const popup = document.getElementById('settingsPopup');
    popup.classList.toggle('show');
}

/**
 * Toggle turbo mode
 */
function toggleTurbo() {
    turboMode = !turboMode;
    const toggle = document.getElementById('turbo-toggle');
    
    if (turboMode) {
        toggle.classList.add('active');
        thinkingMode = false; // ‚≠ê Disable thinking when turbo enabled
        document.getElementById('thinking-toggle').classList.remove('active');
    } else {
        toggle.classList.remove('active');
    }
    
    updateStatusText();
}

/**
 * ‚≠ê NEW: Toggle thinking mode
 */
function toggleThinking() {
    thinkingMode = !thinkingMode;
    const toggle = document.getElementById('thinking-toggle');
    
    if (thinkingMode) {
        toggle.classList.add('active');
        turboMode = false; // Disable turbo when thinking enabled
        document.getElementById('turbo-toggle').classList.remove('active');
    } else {
        toggle.classList.remove('active');
    }
    
    updateStatusText();
}

/**
 * Update status text
 */
function updateStatusText() {
    const statusText = document.getElementById('statusText');
    let modeText = currentMode === 'action' ? 'Answer' : 
                   currentMode === 'array' ? 'Array' : 'Picture';
    
    let presetName = 'Loading...';
    if (allPresets[currentMode] && allPresets[currentMode][currentPreset]) {
        presetName = allPresets[currentMode][currentPreset].DISPLAY_NAME;
    }
    
    let tempText = currentTemperature === 0 ? 'Exact' :
                   currentTemperature === 0.2 ? 'Balanced' :
                   currentTemperature === 0.4 ? 'Expressive' : 'Creative';
    
    statusText.textContent = modeText + ' ‚Ä¢ ' + presetName + ' ‚Ä¢ ' + tempText;
}

/**
 * Update send button state
 */
function updateSendButton() {
    const sendButton = document.getElementById('sendButton');
    
    if (isProcessing) {
        sendButton.disabled = true;
        sendButton.classList.add('spinning');
    } else if (isTyping) {
        sendButton.disabled = false;
        sendButton.classList.remove('spinning');
    } else {
        sendButton.disabled = false;
        sendButton.classList.remove('spinning');
    }
}

/**
 * Handle send button click
 */
function handleSend() {
    if (isTyping) {
        skipTyping();
        return;
    }
    
    const input = document.getElementById('messageInput');
    const message = input.value.trim();
    
    if (!message || isProcessing) return;
    
    input.value = '';
    input.style.height = 'auto';
    
    addMessage(message, 'user');
    sendMessage(message);
}

/**
 * Send quick action
 */
function sendQuickAction(action) {
    const input = document.getElementById('messageInput');
    input.value = action;
    handleSend();
}

/**
 * ‚≠ê UPDATED: Add message with thinking animation support
 */
function addMessage(text, sender, animate = false) {
    const messages = document.getElementById('messages');
    const emptyState = messages.querySelector('.empty-state');
    if (emptyState) emptyState.remove();

    const messageDiv = document.createElement('div');
    messageDiv.className = 'message ' + sender;

    // ‚≠ê Check if response has thinking (for bot messages)
    if (sender === 'bot' && typeof text === 'object' && text.thinking && Array.isArray(text.thinking)) {
        // Create thinking box
        const thinkingBox = document.createElement('div');
        thinkingBox.className = 'thinking-box';
        
        const thinkingHeader = document.createElement('div');
        thinkingHeader.className = 'thinking-header';
        thinkingHeader.innerHTML = 'üí≠ AI Thinking Process';
        
        const thinkingSteps = document.createElement('div');
        thinkingSteps.className = 'thinking-steps';
        
        thinkingBox.appendChild(thinkingHeader);
        thinkingBox.appendChild(thinkingSteps);
        messageDiv.appendChild(thinkingBox);
        
        messages.appendChild(messageDiv);
        scrollToBottom();
        
        // ‚≠ê Animate thinking steps one by one with typing effect
        let stepIndex = 0;
        
        function addNextStep() {
            if (stepIndex >= text.thinking.length) {
                // All thinking steps done, now show answer
                setTimeout(() => {
                    const content = document.createElement('div');
                    content.className = 'message-content';
                    
                    const copyButton = document.createElement('button');
                    copyButton.className = 'copy-button tooltip';
                    copyButton.innerHTML = 'üóí';
                    copyButton.setAttribute('data-tooltip', 'Copy');
                    copyButton.onclick = function() {
                        copyToClipboard(content.innerHTML, this);
                    };
                    content.appendChild(copyButton);
                    
                    messageDiv.appendChild(content);
                    scrollToBottom();
                    
                    // Type the answer
                    if (animate) {
                        isTyping = true;
                        currentTypingElement = content;
                        currentTypingText = text.answer;
                        updateSendButton();
                        typeWriterByWord(content, text.answer);
                    } else {
                        const withMarkdown = parseMarkdown(text.answer);
                        content.innerHTML = convertLinksToClickable(withMarkdown);
                        if (!content.querySelector('.copy-button')) {
                            content.appendChild(copyButton);
                        }
                        messageDiv.classList.add('typing-finished');
                        scrollToBottom();
                    }
                }, 500);
                return;
            }
            
            const step = text.thinking[stepIndex];
            const stepDiv = document.createElement('div');
            stepDiv.className = 'thinking-step';
            stepDiv.textContent = '';
            stepDiv.style.opacity = '0';
            stepDiv.style.transform = 'translateY(-5px)';
            thinkingSteps.appendChild(stepDiv);
            
            // Fade in
            setTimeout(() => {
                stepDiv.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                stepDiv.style.opacity = '1';
                stepDiv.style.transform = 'translateY(0)';
            }, 50);
            
            // Type the step text word by word
            const words = step.split(' ');
            let wordIndex = 0;
            
            function typeNextWord() {
                if (wordIndex < words.length) {
                    stepDiv.textContent += (wordIndex > 0 ? ' ' : '‚Ä¢ ') + words[wordIndex];
                    wordIndex++;
                    scrollToBottom();
                    setTimeout(typeNextWord, 80); // 80ms per word
                } else {
                    // This step finished, move to next
                    stepIndex++;
                    setTimeout(addNextStep, 500); // 500ms delay before next step
                }
            }
            
            typeNextWord();
        }
        
        addNextStep();
        return; // Exit early since we handled thinking
    }

    // Regular message (no thinking) - original code
    const content = document.createElement('div');
    content.className = 'message-content';
    
    if (sender === 'bot') {
        const copyButton = document.createElement('button');
        copyButton.className = 'copy-button tooltip';
        copyButton.innerHTML = 'üóí';
        copyButton.setAttribute('data-tooltip', 'Copy');
        copyButton.onclick = function() {
            copyToClipboard(content.innerHTML, this);
        };
        content.appendChild(copyButton);
    }
    
    if (sender === 'user' || !animate) {
        if (sender === 'bot') {
            const withMarkdown = parseMarkdown(text);
            content.innerHTML = convertLinksToClickable(withMarkdown);
            if (!content.querySelector('.copy-button')) {
                const copyButton = document.createElement('button');
                copyButton.className = 'copy-button tooltip';
                copyButton.innerHTML = 'üóí';
                copyButton.setAttribute('data-tooltip', 'Copy');
                copyButton.onclick = function() {
                    copyToClipboard(content.innerHTML, this);
                };
                content.appendChild(copyButton);
            }
        } else {
            content.textContent = text;
        }
    } else {
        content.innerHTML = '';
        const copyButton = document.createElement('button');
        copyButton.className = 'copy-button tooltip';
        copyButton.innerHTML = 'üóí';
        copyButton.setAttribute('data-tooltip', 'Copy');
        copyButton.onclick = function() {
            copyToClipboard(content.innerHTML, this);
        };
        content.appendChild(copyButton);
    }

    messageDiv.appendChild(content);
    messages.appendChild(messageDiv);

    if (sender === 'bot' && animate) {
        isTyping = true;
        currentTypingElement = content;
        currentTypingText = text;
        updateSendButton();
        typeWriterByWord(content, text);
    } else {
        scrollToBottom();
        if (sender === 'bot') {
            messageDiv.classList.add('typing-finished');
        }
    }
}

/**
 * Copy content to clipboard
 */
function copyToClipboard(html, button) {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;
    
    const copyBtn = tempDiv.querySelector('.copy-button');
    if (copyBtn) copyBtn.remove();
    
    const text = tempDiv.innerText || tempDiv.textContent;
    
    navigator.clipboard.writeText(text).then(() => {
        const originalTooltip = button.getAttribute('data-tooltip');
        button.setAttribute('data-tooltip', 'Copied!');
        button.classList.add('copied');
        
        setTimeout(() => {
            button.setAttribute('data-tooltip', originalTooltip);
            button.classList.remove('copied');
        }, 2000);
    }).catch(err => {
        console.error('Failed to copy:', err);
    });
}

/**
 * Typewriter effect by word
 */
function typeWriterByWord(element, text) {
    const withMarkdown = parseMarkdown(text);
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = withMarkdown;
    
    const textContent = tempDiv.textContent || tempDiv.innerText;
    const words = textContent.split(/(\s+)/);
    
    let currentIndex = 0;
    let currentText = '';
    
    function typeNextWord() {
        if (currentIndex < words.length && isTyping) {
            currentText += words[currentIndex];
            
            const formatted = parseMarkdown(currentText);
            element.innerHTML = convertLinksToClickable(formatted);
            
            const copyButton = element.querySelector('.copy-button');
            if (!copyButton) {
                const btn = document.createElement('button');
                btn.className = 'copy-button tooltip';
                btn.innerHTML = 'üóí';
                btn.setAttribute('data-tooltip', 'Copy');
                btn.onclick = function() {
                    copyToClipboard(element.innerHTML, this);
                };
                element.appendChild(btn);
            }
            
            scrollToBottom();
            currentIndex++;
            setTimeout(typeNextWord, 50);
        } else {
            const formatted = parseMarkdown(text);
            element.innerHTML = convertLinksToClickable(formatted);
            
            const copyButton = element.querySelector('.copy-button');
            if (!copyButton) {
                const btn = document.createElement('button');
                btn.className = 'copy-button tooltip';
                btn.innerHTML = 'üóí';
                btn.setAttribute('data-tooltip', 'Copy');
                btn.onclick = function() {
                    copyToClipboard(element.innerHTML, this);
                };
                element.appendChild(btn);
            }
            
            element.parentElement.classList.add('typing-finished');
            
            isTyping = false;
            currentTypingElement = null;
            currentTypingText = '';
            updateSendButton();
            scrollToBottom();
        }
    }
    
    typeNextWord();
}

/**
 * Skip typing animation
 */
function skipTyping() {
    if (!isTyping || !currentTypingElement || !currentTypingText) return;
    
    isTyping = false;
    
    const formatted = parseMarkdown(currentTypingText);
    currentTypingElement.innerHTML = convertLinksToClickable(formatted);
    
    const copyButton = currentTypingElement.querySelector('.copy-button');
    if (!copyButton) {
        const btn = document.createElement('button');
        btn.className = 'copy-button tooltip';
        btn.innerHTML = 'üóí';
        btn.setAttribute('data-tooltip', 'Copy');
        btn.onclick = function() {
            copyToClipboard(currentTypingElement.innerHTML, this);
        };
        currentTypingElement.appendChild(btn);
    }
    
    currentTypingElement.parentElement.classList.add('typing-finished');
    
    currentTypingElement = null;
    currentTypingText = '';
    updateSendButton();
    scrollToBottom();
}

/**
 * Parse markdown
 */
function parseMarkdown(text) {
    if (!text) return '';
    
    let parsed = String(text);
    
    parsed = parsed.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    parsed = parsed.replace(/\n/g, '<br>');
    
    return parsed;
}

/**
 * Convert links to clickable
 */
function convertLinksToClickable(text) {
    if (!text) return '';
    
    const urlRegex = /(https?:\/\/[^\s<]+)/g;
    return text.replace(urlRegex, '<a href="$1" target="_blank" style="color: #0066cc; text-decoration: underline;">$1</a>');
}

/**
 * Show typing indicator
 */
function showTypingIndicator() {
    const messages = document.getElementById('messages');
    const typingDiv = document.createElement('div');
    typingDiv.className = 'message bot';
    typingDiv.id = 'typing-indicator';

    const indicator = document.createElement('div');
    indicator.className = 'typing-indicator';
    indicator.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect width="10" height="10" x="1" y="1" fill="#8360c3" rx="1"><animate id="svgSpinnersBlocksShuffle30" fill="freeze" attributeName="x" begin="0;svgSpinnersBlocksShuffle3b.end" dur="0.21s" values="1;13"/><animate id="svgSpinnersBlocksShuffle31" fill="freeze" attributeName="y" begin="svgSpinnersBlocksShuffle38.end" dur="0.21s" values="1;13"/><animate id="svgSpinnersBlocksShuffle32" fill="freeze" attributeName="x" begin="svgSpinnersBlocksShuffle39.end" dur="0.21s" values="13;1"/><animate id="svgSpinnersBlocksShuffle33" fill="freeze" attributeName="y" begin="svgSpinnersBlocksShuffle3a.end" dur="0.21s" values="13;1"/></rect><rect width="10" height="10" x="1" y="13" fill="#8360c3" rx="1"><animate id="svgSpinnersBlocksShuffle34" fill="freeze" attributeName="y" begin="svgSpinnersBlocksShuffle30.end" dur="0.21s" values="13;1"/><animate id="svgSpinnersBlocksShuffle35" fill="freeze" attributeName="x" begin="svgSpinnersBlocksShuffle31.end" dur="0.21s" values="1;13"/><animate id="svgSpinnersBlocksShuffle36" fill="freeze" attributeName="y" begin="svgSpinnersBlocksShuffle32.end" dur="0.21s" values="1;13"/><animate id="svgSpinnersBlocksShuffle37" fill="freeze" attributeName="x" begin="svgSpinnersBlocksShuffle33.end" dur="0.21s" values="13;1"/></rect><rect width="10" height="10" x="13" y="13" fill="#8360c3" rx="1"><animate id="svgSpinnersBlocksShuffle38" fill="freeze" attributeName="x" begin="svgSpinnersBlocksShuffle34.end" dur="0.21s" values="13;1"/><animate id="svgSpinnersBlocksShuffle39" fill="freeze" attributeName="y" begin="svgSpinnersBlocksShuffle35.end" dur="0.21s" values="13;1"/><animate id="svgSpinnersBlocksShuffle3a" fill="freeze" attributeName="x" begin="svgSpinnersBlocksShuffle36.end" dur="0.21s" values="1;13"/><animate id="svgSpinnersBlocksShuffle3b" fill="freeze" attributeName="y" begin="svgSpinnersBlocksShuffle37.end" dur="0.21s" values="1;13"/></rect></svg>';

    typingDiv.appendChild(indicator);
    messages.appendChild(typingDiv);
    scrollToBottom();
}

/**
 * Remove typing indicator
 */
function removeTypingIndicator() {
    const indicator = document.getElementById('typing-indicator');
    if (indicator) indicator.remove();
}

/**
 * Scroll to bottom
 */
function scrollToBottom() {
    const messages = document.getElementById('messages');
    setTimeout(() => {
        messages.scrollTop = messages.scrollHeight;
    }, 10);
}

/**
 * ‚≠ê UPDATED: Send message with thinking mode support
 */
function sendMessage(message) {
    if (isProcessing) return;
    
    isProcessing = true;
    updateSendButton();
    showTypingIndicator();
    
    google.script.run
        .withSuccessHandler(function(response) {
            removeTypingIndicator();
            
            // ‚≠ê Check if response is JSON (thinking mode)
            if (typeof response === 'string' && response.trim().startsWith('{')) {
                try {
                    const parsedResponse = JSON.parse(response);
                    if (parsedResponse.thinking && parsedResponse.answer) {
                        // Thinking mode response
                        addMessage(parsedResponse, 'bot', true);
                        isProcessing = false;
                        updateSendButton();
                        return;
                    }
                } catch (e) {
                    // Not JSON, treat as regular response
                }
            }
            
            // Regular response
            if (currentMode === 'array') {
                addMessage(response, 'bot', false);
            } else {
                addMessage(response, 'bot', true);
            }
            
            isProcessing = false;
            updateSendButton();
        })
        .withFailureHandler(function(error) {
            removeTypingIndicator();
            addMessage('‚ùå Error: ' + error.message, 'bot', false);
            isProcessing = false;
            updateSendButton();
        })
        .processRealUniverseAI(message, currentPreset, currentTemperature, currentMode, turboMode, thinkingMode);
}

// Initialize on load
window.onload = init;
</script>
</body>
</html>`;
}
